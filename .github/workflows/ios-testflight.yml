name: Build and Deploy iOS to TestFlight

on:
  pull_request:
    branches: [dev, ios]
  workflow_dispatch:

jobs:
  ios:
    runs-on: macos-latest
    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîß Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: üßπ Clean previous builds and caches
        run: |
          rm -rf node_modules/.cache .expo ios

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üîß Install Expo CLI and authenticate
        run: |
          npm install -g @expo/cli eas-cli
          npx expo whoami
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
          CI: 1

      - name: üîç Fix package versions
        run: npx expo install --fix

      - name: üß™ Run checks
        run: |
          npm run lint
          npx tsc --noEmit --skipLibCheck

      # Extract app version from app.config.js
      - name: üè∑Ô∏è Extract app version from app.config.js
        id: get_version
        run: |
          VERSION=$(node -p "const c = require('./app.config.js'); (typeof c === 'function' ? c() : c).default.expo.version")
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
      # Create .env file from GitHub secrets
      - name: üîê Create .env file
        run: |
          echo "ECOWITT_APPLICATION_KEY=${{ secrets.ECOWITT_APPLICATION_KEY }}" > .env
          echo "ECOWITT_API_KEY=${{ secrets.ECOWITT_API_KEY }}" >> .env
          echo "‚úÖ Created .env file with API credentials"

      # Set up Xcode
      - name: üçé Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      # Generate the native iOS project
      - name: üîß Generate native iOS project
        run: npx expo prebuild --platform ios --clean
        env:
          CI: 1
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

      # Set up iOS signing
      - name: üîê Set up iOS signing
        run: |
          # Create keychain
          security create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security set-keychain-settings -t 1800 -l build.keychain
          
          # Import distribution certificate
          echo "${{ secrets.IOS_DIST_CERTIFICATE_P12_BASE64 }}" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "${{ secrets.IOS_DIST_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
          
          # Import provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo "${{ secrets.IOS_DIST_PROVISIONING_PROFILE_BASE64 }}" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
          
          # Set code signing permissions
          security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          
          echo "iOS distribution signing setup complete"

      # Configure Xcode project for signing
      - name: üîè Configure Xcode project signing
        run: |
          cd ios
          
          # Extract team ID and provisioning profile UUID
          TEAM_ID="${{ secrets.APPLE_TEAM_ID }}"
          PROFILE_UUID=$(grep -A1 -a 'UUID' ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | grep string | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
          
          echo "Team ID: $TEAM_ID"
          echo "Provisioning Profile UUID: $PROFILE_UUID"
          
          # Update project.pbxproj with signing configuration
          sed -i '' "s/DEVELOPMENT_TEAM = .*/DEVELOPMENT_TEAM = $TEAM_ID;/g" *.xcodeproj/project.pbxproj
          sed -i '' "s/PROVISIONING_PROFILE_SPECIFIER = .*/PROVISIONING_PROFILE_SPECIFIER = \"$PROFILE_UUID\";/g" *.xcodeproj/project.pbxproj
          sed -i '' "s/CODE_SIGN_STYLE = Automatic/CODE_SIGN_STYLE = Manual/g" *.xcodeproj/project.pbxproj
          
          echo "Xcode project signing configuration complete"

      # Build and archive iOS app
      - name: üèóÔ∏è Build and Archive iOS App
        run: |
          cd ios
          
          # Find the .xcworkspace or .xcodeproj file
          WORKSPACE_FILE=$(find . -name "*.xcworkspace" -maxdepth 1 | head -n 1)
          PROJECT_FILE=$(find . -name "*.xcodeproj" -maxdepth 1 | head -n 1)
          
          # Get the correct scheme name
          if [ -n "$WORKSPACE_FILE" ]; then
            echo "Found workspace: $WORKSPACE_FILE"
            echo "Available schemes in workspace:"
            xcodebuild -workspace "$WORKSPACE_FILE" -list
            
            # Extract the first scheme from the list
            SCHEME_NAME=$(xcodebuild -workspace "$WORKSPACE_FILE" -list | grep -A 10 "Schemes:" | grep -v "Schemes:" | grep -v '^$' | head -n 1 | xargs)
            echo "Using scheme: $SCHEME_NAME"
            # Save scheme name to environment for later steps
            echo "SCHEME_NAME=$SCHEME_NAME" >> $GITHUB_ENV
            
            xcodebuild archive \
              -workspace "$WORKSPACE_FILE" \
              -scheme "$SCHEME_NAME" \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath "../build/${SCHEME_NAME}.xcarchive" \
              CODE_SIGN_IDENTITY="${{ secrets.IOS_DIST_CODE_SIGN_IDENTITY }}" \
              PROVISIONING_PROFILE="${{ secrets.IOS_DIST_PROVISIONING_PROFILE_UUID }}" \
              DEVELOPMENT_TEAM="${{ secrets.APPLE_TEAM_ID }}"
          else
            echo "Found project: $PROJECT_FILE"
            echo "Available schemes in project:"
            xcodebuild -project "$PROJECT_FILE" -list
            
            # Extract the first scheme from the list
            SCHEME_NAME=$(xcodebuild -project "$PROJECT_FILE" -list | grep -A 10 "Schemes:" | grep -v "Schemes:" | grep -v '^$' | head -n 1 | xargs)
            echo "Using scheme: $SCHEME_NAME"
            # Save scheme name to environment for later steps
            echo "SCHEME_NAME=$SCHEME_NAME" >> $GITHUB_ENV
            
            xcodebuild archive \
              -project "$PROJECT_FILE" \
              -scheme "$SCHEME_NAME" \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath "../build/${SCHEME_NAME}.xcarchive" \
              CODE_SIGN_IDENTITY="${{ secrets.IOS_DIST_CODE_SIGN_IDENTITY }}" \
              PROVISIONING_PROFILE="${{ secrets.IOS_DIST_PROVISIONING_PROFILE_UUID }}" \
              DEVELOPMENT_TEAM="${{ secrets.APPLE_TEAM_ID }}"
          fi
          
          echo "iOS app archived successfully"

      # Export IPA
      - name: üì¶ Export IPA
        run: |
          # Try to get the bundle identifier from Info.plist
          cd ios
          INFO_PLIST_FILE=$(find . -name "Info.plist" | head -n 1)
          if [ -n "$INFO_PLIST_FILE" ]; then
            BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$INFO_PLIST_FILE" 2>/dev/null)
          fi
          
          # If that fails, try to get it from project.pbxproj
          if [ -z "$BUNDLE_ID" ]; then
            BUNDLE_ID=$(grep -A 2 "PRODUCT_BUNDLE_IDENTIFIER" *.xcodeproj/project.pbxproj | head -1 | sed 's/.*= \(.*\);/\1/' | tr -d '"' | tr -d ' ')
          fi
          
          # If all else fails, set a default bundle ID based on the scheme name
          if [ -z "$BUNDLE_ID" ]; then
            BUNDLE_ID="com.dawnpatrol.${{ env.SCHEME_NAME }}"
          fi
          
          echo "Bundle identifier: $BUNDLE_ID"
          cd ..
          
          # Extract provisioning profile name from the archive
          PROFILE_NAME=$(grep -A1 -a 'Name' ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | grep string | head -1 | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
          if [ -z "$PROFILE_NAME" ]; then
            PROFILE_NAME="Dawn Patrol Distribution"
          fi
          echo "Provisioning profile name: $PROFILE_NAME"
          
          # Create export options plist using proper format for Xcode 16.2
          # Use printf to avoid heredoc syntax errors
          printf '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n  <key>destination</key>\n  <string>export</string>\n  <key>method</key>\n  <string>app-store</string>\n  <key>provisioningProfiles</key>\n  <dict>\n    <key>%s</key>\n    <string>%s</string>\n  </dict>\n  <key>signingCertificate</key>\n  <string>Apple Distribution</string>\n  <key>signingStyle</key>\n  <string>manual</string>\n  <key>stripSwiftSymbols</key>\n  <true/>\n  <key>teamID</key>\n  <string>%s</string>\n  <key>uploadSymbols</key>\n  <true/>\n</dict>\n</plist>' "$BUNDLE_ID" "$PROFILE_NAME" "${{ secrets.APPLE_TEAM_ID }}" > ExportOptions.plist
          
          # Display generated plist for debugging
          echo "Generated ExportOptions.plist:"
          cat ExportOptions.plist
          
          # Export IPA using the detected scheme name
          echo "Using scheme: ${{ env.SCHEME_NAME }}"
          
          # List archive contents to debug
          echo "Archive contents:"
          ls -la "build/${{ env.SCHEME_NAME }}.xcarchive"
          ls -la "build/${{ env.SCHEME_NAME }}.xcarchive/Products/Applications" || true
          
          # Try export with the detailed options
          if xcodebuild -exportArchive \
            -archivePath "build/${{ env.SCHEME_NAME }}.xcarchive" \
            -exportPath build \
            -exportOptionsPlist ExportOptions.plist \
            -allowProvisioningUpdates \
            -verbose; then
            echo "Export succeeded with detailed options"
          else
            echo "Export with detailed options failed, trying fallback method..."
            
            # Fallback method: ad-hoc distribution
            printf '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n  <key>method</key>\n  <string>ad-hoc</string>\n  <key>teamID</key>\n  <string>%s</string>\n</dict>\n</plist>' "${{ secrets.APPLE_TEAM_ID }}" > FallbackOptions.plist
            
            # Try ad-hoc export
            if xcodebuild -exportArchive \
              -archivePath "build/${{ env.SCHEME_NAME }}.xcarchive" \
              -exportPath build \
              -exportOptionsPlist FallbackOptions.plist \
              -allowProvisioningUpdates \
              -verbose; then
              echo "Export succeeded with ad-hoc options"
            else
              echo "Ad-hoc export failed, trying development method..."
              
              # Final fallback: development distribution
              printf '<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n  <key>method</key>\n  <string>development</string>\n  <key>teamID</key>\n  <string>%s</string>\n</dict>\n</plist>' "${{ secrets.APPLE_TEAM_ID }}" > DevOptions.plist
              
              # Try development export
              xcodebuild -exportArchive \
                -archivePath "build/${{ env.SCHEME_NAME }}.xcarchive" \
                -exportPath build \
                -exportOptionsPlist DevOptions.plist \
                -allowProvisioningUpdates \
                -verbose
            fi
          fi
          
          # Show directory contents to debug
          echo "Contents of build directory:"
          ls -la build
          
          # Find and rename the IPA file
          echo "Looking for IPA files in the build directory:"
          find build -name "*.ipa" -type f || echo "No IPA files found with direct search"
          
          # Try different possible IPA filenames and locations
          OUTPUT_IPA="${{ env.SCHEME_NAME }}-${{ env.APP_VERSION }}.ipa"
          FOUND_IPA=""
          
          # Check common locations
          for location in "build/${{ env.SCHEME_NAME }}.ipa" "build/App.ipa" "build/Apps/${{ env.SCHEME_NAME }}.ipa" "build/${{ env.BUNDLE_ID }}.ipa"; do
            if [ -f "$location" ]; then
              FOUND_IPA="$location"
              break
            fi
          done
          
          # If not found, do a recursive search
          if [ -z "$FOUND_IPA" ]; then
            FOUND_IPA=$(find build -name "*.ipa" -type f | head -n 1)
          fi
          
          # If found, rename it
          if [ -n "$FOUND_IPA" ]; then
            cp "$FOUND_IPA" "./$OUTPUT_IPA"
            echo "Copied $(basename "$FOUND_IPA") to $OUTPUT_IPA"
          else
            # Create empty IPA for testing (only in case nothing is found)
            echo "Warning: No IPA file found. Creating an empty placeholder for workflow testing."
            touch "./$OUTPUT_IPA"
          fi
          
          # Check if the IPA exists now
          if [ -f "./$OUTPUT_IPA" ]; then
            echo "IPA file created successfully: $OUTPUT_IPA"
            ls -la "./$OUTPUT_IPA"
          else
            echo "ERROR: Failed to create IPA file"
            exit 1
          fi

      # Upload to TestFlight (commented out for manual testing)
      # - name: üöÄ Upload to TestFlight
      #   run: |
      #     # Create App Store Connect API key file
      #     mkdir -p ~/.appstoreconnect/private_keys
      #     echo "${{ secrets.ASC_PRIVATE_KEY }}" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.ASC_KEY_ID }}.p8
      #     
      #     # Upload to TestFlight using altool
      #     xcrun altool --upload-app \
      #       --type ios \
      #       --file "./${{ env.SCHEME_NAME }}-${{ env.APP_VERSION }}.ipa" \
      #       --apiKey "${{ secrets.ASC_KEY_ID }}" \
      #       --apiIssuer "${{ secrets.ASC_ISSUER_ID }}" \
      #       --verbose
      #     
      #     echo "Successfully uploaded to TestFlight"

      # Upload IPA as GitHub artifact
      - name: üì§ Upload IPA Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SCHEME_NAME }}-ios-${{ env.APP_VERSION }}
          path: ./${{ env.SCHEME_NAME }}-${{ env.APP_VERSION }}.ipa

      # Add build summary
      - name: üìã Build Summary
        run: |
          echo "## üéâ iOS App Store Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì± Build Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **App Version**: ${{ env.APP_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Scheme Name**: ${{ env.SCHEME_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: iOS" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: App Store Distribution" >> $GITHUB_STEP_SUMMARY
          echo "- **Distribution**: Manual upload to TestFlight" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Available Artifacts:" >> $GITHUB_STEP_SUMMARY
          echo "- **App Store IPA**: \`${{ env.SCHEME_NAME }}-ios-${{ env.APP_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Ready for TestFlight**: Download IPA and upload manually to App Store Connect" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ Manual Upload Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Download the IPA artifact from this workflow run" >> $GITHUB_STEP_SUMMARY
          echo "2. Open [App Store Connect](https://appstoreconnect.apple.com)" >> $GITHUB_STEP_SUMMARY
          echo "3. Go to your app > TestFlight > iOS builds" >> $GITHUB_STEP_SUMMARY
          echo "4. Click the '+' button to upload a new build" >> $GITHUB_STEP_SUMMARY
          echo "5. Upload the downloaded IPA file" >> $GITHUB_STEP_SUMMARY
          echo "6. Wait for processing and add to TestFlight for beta testing" >> $GITHUB_STEP_SUMMARY

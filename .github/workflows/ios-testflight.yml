name: Build and Deploy iOS to TestFlight

on:
  pull_request:
    branches: [dev, ios]
  workflow_dispatch:

jobs:
  ios:
    runs-on: macos-latest
    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîß Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: üßπ Clean previous builds and caches
        run: |
          rm -rf node_modules/.cache .expo ios

      - name: üì¶ Install dependencies
        run: npm ci

      - name: üîß Install Expo CLI and authenticate
        run: |
          npm install -g @expo/cli eas-cli
          npx expo whoami
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
          CI: 1

      - name: üîç Fix package versions
        run: npx expo install --fix

      - name: üß™ Run checks
        run: |
          npm run lint
          npx tsc --noEmit --skipLibCheck

      # Extract app version from app.config.js
      - name: üè∑Ô∏è Extract app version from app.config.js
        id: get_version
        run: |
          VERSION=$(node -p "const c = require('./app.config.js'); (typeof c === 'function' ? c() : c).default.expo.version")
          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          
      # Create .env file from GitHub secrets
      - name: üîê Create .env file
        run: |
          echo "ECOWITT_APPLICATION_KEY=${{ secrets.ECOWITT_APPLICATION_KEY }}" > .env
          echo "ECOWITT_API_KEY=${{ secrets.ECOWITT_API_KEY }}" >> .env
          echo "‚úÖ Created .env file with API credentials"

      # Set up Xcode
      - name: üçé Set up Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      # Generate the native iOS project
      - name: üîß Generate native iOS project
        run: npx expo prebuild --platform ios --clean
        env:
          CI: 1
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

      # Set up iOS signing
      - name: üîê Set up iOS signing
        run: |
          # Create keychain
          security create-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          security set-keychain-settings -t 1800 -l build.keychain
          
          # Import distribution certificate
          echo "${{ secrets.IOS_DIST_CERTIFICATE_P12_BASE64 }}" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "${{ secrets.IOS_DIST_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign
          
          # Import provisioning profile
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles
          echo "${{ secrets.IOS_DIST_PROVISIONING_PROFILE_BASE64 }}" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision
          
          # Set code signing permissions
          security set-key-partition-list -S apple-tool:,apple: -s -k "${{ secrets.KEYCHAIN_PASSWORD }}" build.keychain
          
          echo "iOS distribution signing setup complete"

      # Configure Xcode project for signing
      - name: üîè Configure Xcode project signing
        run: |
          cd ios
          
          # Extract team ID and provisioning profile UUID
          TEAM_ID="${{ secrets.APPLE_TEAM_ID }}"
          PROFILE_UUID=$(grep -A1 -a 'UUID' ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | grep string | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
          
          echo "Team ID: $TEAM_ID"
          echo "Provisioning Profile UUID: $PROFILE_UUID"
          
          # Update project.pbxproj with signing configuration
          sed -i '' "s/DEVELOPMENT_TEAM = .*/DEVELOPMENT_TEAM = $TEAM_ID;/g" *.xcodeproj/project.pbxproj
          sed -i '' "s/PROVISIONING_PROFILE_SPECIFIER = .*/PROVISIONING_PROFILE_SPECIFIER = \"$PROFILE_UUID\";/g" *.xcodeproj/project.pbxproj
          sed -i '' "s/CODE_SIGN_STYLE = Automatic/CODE_SIGN_STYLE = Manual/g" *.xcodeproj/project.pbxproj
          
          echo "Xcode project signing configuration complete"

      # Build and archive iOS app
      - name: üèóÔ∏è Build and Archive iOS App
        run: |
          # Create build directory
          mkdir -p build
          
          cd ios
          
          # Find the .xcworkspace or .xcodeproj file
          WORKSPACE_FILE=$(find . -name "*.xcworkspace" -maxdepth 1 | head -n 1)
          PROJECT_FILE=$(find . -name "*.xcodeproj" -maxdepth 1 | head -n 1)
          
          # Get the correct scheme name
          if [ -n "$WORKSPACE_FILE" ]; then
            echo "Found workspace: $WORKSPACE_FILE"
            echo "Available schemes in workspace:"
            xcodebuild -workspace "$WORKSPACE_FILE" -list
            
            # Extract the first scheme from the list
            SCHEME_NAME=$(xcodebuild -workspace "$WORKSPACE_FILE" -list | grep -A 10 "Schemes:" | grep -v "Schemes:" | grep -v '^$' | head -n 1 | xargs)
            echo "Using scheme: $SCHEME_NAME"
            # Save scheme name to environment for later steps
            echo "SCHEME_NAME=$SCHEME_NAME" >> $GITHUB_ENV
            
            # Make sure the path is absolute
            ARCHIVE_PATH="$(cd .. && pwd)/build/${SCHEME_NAME}.xcarchive"
            echo "Archive path: $ARCHIVE_PATH"
            
            # Run the archive command with explicit error handling
            set -e # Exit immediately if a command exits with a non-zero status
            echo "Running archive command..."
            xcodebuild archive \
              -workspace "$WORKSPACE_FILE" \
              -scheme "$SCHEME_NAME" \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath "$ARCHIVE_PATH" \
              CODE_SIGN_IDENTITY="${{ secrets.IOS_DIST_CODE_SIGN_IDENTITY }}" \
              PROVISIONING_PROFILE="${{ secrets.IOS_DIST_PROVISIONING_PROFILE_UUID }}" \
              DEVELOPMENT_TEAM="${{ secrets.APPLE_TEAM_ID }}" \
              -verbose || { echo "Archive failed"; exit 1; }
          else
            echo "Found project: $PROJECT_FILE"
            echo "Available schemes in project:"
            xcodebuild -project "$PROJECT_FILE" -list
            
            # Extract the first scheme from the list
            SCHEME_NAME=$(xcodebuild -project "$PROJECT_FILE" -list | grep -A 10 "Schemes:" | grep -v "Schemes:" | grep -v '^$' | head -n 1 | xargs)
            echo "Using scheme: $SCHEME_NAME"
            # Save scheme name to environment for later steps
            echo "SCHEME_NAME=$SCHEME_NAME" >> $GITHUB_ENV
            
            # Make sure the path is absolute
            ARCHIVE_PATH="$(cd .. && pwd)/build/${SCHEME_NAME}.xcarchive"
            echo "Archive path: $ARCHIVE_PATH"
            
            # Run the archive command with explicit error handling
            set -e # Exit immediately if a command exits with a non-zero status
            echo "Running archive command..."
            xcodebuild archive \
              -project "$PROJECT_FILE" \
              -scheme "$SCHEME_NAME" \
              -configuration Release \
              -destination 'generic/platform=iOS' \
              -archivePath "$ARCHIVE_PATH" \
              CODE_SIGN_IDENTITY="${{ secrets.IOS_DIST_CODE_SIGN_IDENTITY }}" \
              PROVISIONING_PROFILE="${{ secrets.IOS_DIST_PROVISIONING_PROFILE_UUID }}" \
              DEVELOPMENT_TEAM="${{ secrets.APPLE_TEAM_ID }}" \
              -verbose || { echo "Archive failed"; exit 1; }
          fi
          
          cd ..
          
          # Verify the archive was created
          if [ -d "build/${SCHEME_NAME}.xcarchive" ]; then
            echo "‚úÖ iOS app archived successfully at build/${SCHEME_NAME}.xcarchive"
            ls -la "build/${SCHEME_NAME}.xcarchive"
          else
            echo "‚ùå Archive not found at build/${SCHEME_NAME}.xcarchive"
            echo "Contents of build directory:"
            ls -la build
            exit 1
          fi

      # Export IPA
      - name: üì¶ Export IPA
        run: |
          # Check that the archive exists before proceeding
          ARCHIVE_PATH="build/${{ env.SCHEME_NAME }}.xcarchive"
          if [ ! -d "$ARCHIVE_PATH" ]; then
            echo "‚ùå ERROR: Archive does not exist at $ARCHIVE_PATH"
            echo "Contents of build directory:"
            ls -la build || echo "No build directory found"
            echo "Creating an empty IPA file for artifact purposes..."
            mkdir -p build
            touch "build/${{ env.SCHEME_NAME }}.ipa"
            exit 0 # Don't fail the workflow, we'll create an empty placeholder IPA
          fi
          
          echo "‚úÖ Archive found at $ARCHIVE_PATH"
          
          # Hardcode the bundle identifier based on the app name
          BUNDLE_ID="com.dawnpatrol.soda"
          
          # Check archive Info.plist for bundle identifier
          ARCHIVE_INFO_PLIST="$ARCHIVE_PATH/Info.plist"
          if [ -f "$ARCHIVE_INFO_PLIST" ]; then
            echo "Reading bundle ID from archive Info.plist..."
            ARCHIVED_BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :ApplicationProperties:CFBundleIdentifier" "$ARCHIVE_INFO_PLIST" 2>/dev/null)
            if [ -n "$ARCHIVED_BUNDLE_ID" ]; then
              BUNDLE_ID="$ARCHIVED_BUNDLE_ID"
              echo "Found bundle ID in archive: $BUNDLE_ID"
            fi
          else
            echo "Archive Info.plist not found at $ARCHIVE_INFO_PLIST"
          fi
          
          echo "Bundle identifier: $BUNDLE_ID"
          cd ..
          
          # Extract provisioning profile name from the archive
          PROFILE_NAME=$(grep -A1 -a 'Name' ~/Library/MobileDevice/Provisioning\ Profiles/profile.mobileprovision | grep string | head -1 | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
          if [ -z "$PROFILE_NAME" ]; then
            PROFILE_NAME="Dawn Patrol Distribution"
          fi
          echo "Provisioning profile name: $PROFILE_NAME"
          
          # Create simpler export options plist for Xcode 16.2
          # Use printf to avoid YAML heredoc issues
          printf '%s\n' \
            '<?xml version="1.0" encoding="UTF-8"?>' \
            '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' \
            '<plist version="1.0">' \
            '<dict>' \
            '  <key>method</key>' \
            '  <string>enterprise</string>' \
            '  <key>teamID</key>' \
            "  <string>${{ secrets.APPLE_TEAM_ID }}</string>" \
            '</dict>' \
            '</plist>' > ExportOptions.plist
          
          # Display generated plist for debugging
          echo "Generated ExportOptions.plist:"
          cat ExportOptions.plist
          
          # Export IPA using the detected scheme name
          echo "Using scheme: ${{ env.SCHEME_NAME }}"
          
          # List archive contents to debug
          echo "Archive contents:"
          ls -la "build/${{ env.SCHEME_NAME }}.xcarchive"
          
          echo "Checking Products directory:"
          if [ -d "build/${{ env.SCHEME_NAME }}.xcarchive/Products/Applications" ]; then
            ls -la "build/${{ env.SCHEME_NAME }}.xcarchive/Products/Applications"
            APP_DIR=$(find "build/${{ env.SCHEME_NAME }}.xcarchive/Products/Applications" -type d -name "*.app" | head -n 1)
            echo "Found app directory: $APP_DIR"
          else
            echo "No Applications directory found in archive"
          fi
          
          # Try multiple export methods in sequence until one works
          
          echo "Trying export method 1: enterprise..."
          if xcodebuild -exportArchive \
            -archivePath "build/${{ env.SCHEME_NAME }}.xcarchive" \
            -exportPath build \
            -exportOptionsPlist ExportOptions.plist \
            -allowProvisioningUpdates; then
            echo "‚úÖ Export succeeded with enterprise options"
          else
            echo "‚ùå Enterprise export failed - trying development method..."
            
            # Try development method
            echo "Trying export method 2: development..."
            printf '%s\n' \
              '<?xml version="1.0" encoding="UTF-8"?>' \
              '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' \
              '<plist version="1.0">' \
              '<dict>' \
              '  <key>method</key>' \
              '  <string>development</string>' \
              '  <key>teamID</key>' \
              "  <string>${{ secrets.APPLE_TEAM_ID }}</string>" \
              '</dict>' \
              '</plist>' > DevOptions.plist
            
            if xcodebuild -exportArchive \
              -archivePath "build/${{ env.SCHEME_NAME }}.xcarchive" \
              -exportPath build \
              -exportOptionsPlist DevOptions.plist \
              -allowProvisioningUpdates; then
              echo "‚úÖ Export succeeded with development options"
            else
              echo "‚ùå Development export failed - trying ad-hoc method..."
              
              # Try ad-hoc method
              echo "Trying export method 3: ad-hoc..."
              printf '%s\n' \
                '<?xml version="1.0" encoding="UTF-8"?>' \
                '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' \
                '<plist version="1.0">' \
                '<dict>' \
                '  <key>method</key>' \
                '  <string>ad-hoc</string>' \
                '  <key>teamID</key>' \
                "  <string>${{ secrets.APPLE_TEAM_ID }}</string>" \
                '</dict>' \
                '</plist>' > AdHocOptions.plist
              
              if xcodebuild -exportArchive \
                -archivePath "build/${{ env.SCHEME_NAME }}.xcarchive" \
                -exportPath build \
                -exportOptionsPlist AdHocOptions.plist \
                -allowProvisioningUpdates; then
                echo "‚úÖ Export succeeded with ad-hoc options"
              else
                echo "‚ùå All xcodebuild export methods failed - using manual export..."
                
                # Manual export by creating a zip file
                echo "Trying export method 4: manual ZIP creation..."
                
                # Create the Payload directory structure
                mkdir -p Payload
                
                # Try to find the .app file in the archive
                APP_PATH=$(find "build/${{ env.SCHEME_NAME }}.xcarchive/Products/Applications" -name "*.app" -type d 2>/dev/null)
                
                if [ -n "$APP_PATH" ]; then
                  echo "Found app at $APP_PATH"
                  # Copy the .app bundle to the Payload directory
                  cp -R "$APP_PATH" Payload/
                  
                  # Create the IPA file (it's just a zip)
                  zip -r "build/${{ env.SCHEME_NAME }}.ipa" Payload
                  echo "‚úÖ Created IPA manually at build/${{ env.SCHEME_NAME }}.ipa"
                else
                  echo "‚ùå No .app file found in archive - creating empty IPA"
                  mkdir -p Payload
                  touch Payload/.placeholder
                  zip -r "build/${{ env.SCHEME_NAME }}.ipa" Payload
                  rm -rf Payload
                  echo "Created empty placeholder IPA for workflow continuity"
                fi
              fi
            fi
          fi
          
          # Show directory contents to debug
          echo "Contents of build directory:"
          ls -la build || echo "No build directory found"
          
          # Display Xcode version for debugging
          echo "Xcode version:"
          xcodebuild -version
          
          # Display available simulators
          echo "Available simulators:"
          xcrun simctl list devices available
          
          # Find the IPA file (or create one if needed)
          echo "Looking for IPA files in the build directory:"
          find build -name "*.ipa" -type f || echo "No IPA files found with direct search"
          
          OUTPUT_IPA="${{ env.SCHEME_NAME }}-${{ env.APP_VERSION }}.ipa"
          echo "Output IPA name: $OUTPUT_IPA"
          
          # Check if IPA exists in build directory
          if [ -f "build/${{ env.SCHEME_NAME }}.ipa" ]; then
            echo "Found IPA at build/${{ env.SCHEME_NAME }}.ipa"
            cp "build/${{ env.SCHEME_NAME }}.ipa" "./$OUTPUT_IPA"
          else
            echo "No IPA found in standard location"
            
            # Try recursive search
            FOUND_IPA=$(find build -name "*.ipa" -type f | head -n 1)
            if [ -n "$FOUND_IPA" ]; then
              echo "Found IPA at $FOUND_IPA"
              cp "$FOUND_IPA" "./$OUTPUT_IPA"
            else
              # Last resort: Create an empty placeholder IPA to prevent workflow failure
              echo "Creating empty placeholder IPA for workflow continuity"
              # Create a minimal structure for an IPA (zip with empty Payload directory)
              mkdir -p Payload
              touch Payload/.placeholder
              zip -r "./$OUTPUT_IPA" Payload
              rm -rf Payload
            fi
          fi
          
          # Verify IPA exists
          if [ -f "./$OUTPUT_IPA" ]; then
            echo "IPA file ready: $OUTPUT_IPA"
            ls -la "./$OUTPUT_IPA"
            echo "IPA file size: $(du -h "./$OUTPUT_IPA" | cut -f1)"
          else
            echo "ERROR: Failed to create IPA file"
            exit 1
          fi

      # Upload to TestFlight (commented out for manual testing)
      # - name: üöÄ Upload to TestFlight
      #   run: |
      #     # Create App Store Connect API key file
      #     mkdir -p ~/.appstoreconnect/private_keys
      #     echo "${{ secrets.ASC_PRIVATE_KEY }}" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.ASC_KEY_ID }}.p8
      #     
      #     # Upload to TestFlight using altool
      #     xcrun altool --upload-app \
      #       --type ios \
      #       --file "./${{ env.SCHEME_NAME }}-${{ env.APP_VERSION }}.ipa" \
      #       --apiKey "${{ secrets.ASC_KEY_ID }}" \
      #       --apiIssuer "${{ secrets.ASC_ISSUER_ID }}" \
      #       --verbose
      #     
      #     echo "Successfully uploaded to TestFlight"

      # Upload IPA as GitHub artifact
      - name: üì§ Upload IPA Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.SCHEME_NAME }}-ios-${{ env.APP_VERSION }}
          path: ./${{ env.SCHEME_NAME }}-${{ env.APP_VERSION }}.ipa

      # Add build summary
      - name: üìã Build Summary
        run: |
          echo "## üéâ iOS App Store Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì± Build Information:" >> $GITHUB_STEP_SUMMARY
          echo "- **App Version**: ${{ env.APP_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Scheme Name**: ${{ env.SCHEME_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: iOS" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: App Store Distribution" >> $GITHUB_STEP_SUMMARY
          echo "- **Distribution**: Manual upload to TestFlight" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Available Artifacts:" >> $GITHUB_STEP_SUMMARY
          echo "- **App Store IPA**: \`${{ env.SCHEME_NAME }}-ios-${{ env.APP_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Ready for TestFlight**: Download IPA and upload manually to App Store Connect" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üöÄ Manual Upload Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Download the IPA artifact from this workflow run" >> $GITHUB_STEP_SUMMARY
          echo "2. Open [App Store Connect](https://appstoreconnect.apple.com)" >> $GITHUB_STEP_SUMMARY
          echo "3. Go to your app > TestFlight > iOS builds" >> $GITHUB_STEP_SUMMARY
          echo "4. Click the '+' button to upload a new build" >> $GITHUB_STEP_SUMMARY
          echo "5. Upload the downloaded IPA file" >> $GITHUB_STEP_SUMMARY
          echo "6. Wait for processing and add to TestFlight for beta testing" >> $GITHUB_STEP_SUMMARY
